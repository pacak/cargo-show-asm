use crate::esafeprintln;
use ar::Archive;
use cargo_metadata::Artifact;
use std::{
    fs::File,
    path::{Path, PathBuf},
};

pub fn artifact_byproducts(artifact: &Artifact, ext: &str) -> anyhow::Result<Vec<PathBuf>> {
    for file in artifact.filenames.iter() {
        if file.extension() == Some("rmeta") {
            let mut file = PathBuf::from(file);
            file.set_extension("rlib");
            return locate_byproducts(&file, ext);
        }
    }
    anyhow::bail!("no rmeta?");
}

/// Look inside of rlib file to figure out artifact names
///
/// rlib files are ar archives [1] and contain object code generated by compiler. multiple
/// compilation units we can abuse names of the object files to get names of emitted byproducts:
///
/// sample-7aab9f7e7ab26e00.53xe9n61hxojleor.rcgu.o =>
/// sample-7aab9f7e7ab26e00.53xe9n61hxojleor.rcgu.s
///
/// This is needed so we can tell which files were generated
///
/// - [1] https://rustc-dev-guide.rust-lang.org/backend/libs-and-metadata.html
pub fn locate_byproducts(rlib: impl AsRef<Path>, ext: &str) -> anyhow::Result<Vec<PathBuf>> {
    let mut res = Vec::new();
    let rlib = rlib.as_ref();
    let mut archive = Archive::new(File::open(rlib).unwrap());

    let basedir = rlib
        .parent()
        .ok_or_else(|| anyhow::anyhow!("Can't get a folder of {rlib:?}"))?;
    let mut missing = Vec::new();
    while let Some(entry) = archive.next_entry() {
        let entry = entry?;
        let name = std::str::from_utf8(entry.header().identifier())?;
        if name == "lib.rmeta" {
            continue;
        }

        let mut x = basedir.join(name);
        x.set_extension(ext);
        if x.exists() {
            res.push(x)
        } else {
            missing.push(x);
        }
    }
    if !res.is_empty() && missing.is_empty() {
        for file in &missing {
            esafeprintln!("A byproduct is supposed to be located at {file:?}, but it's missing");
        }
    }

    if missing.len() == 1 && res.is_empty() {
        assert_eq!(missing[0].extension().unwrap(), ext);
        let f = missing[0]
            .with_extension("")
            .with_extension("")
            .with_extension("")
            .with_extension(ext);
        return Ok(vec![f]);
    }

    Ok(res)
}

pub fn read_files(paths: &[PathBuf]) -> anyhow::Result<String> {
    let mut res = String::new();

    for file in paths {
        res += &String::from_utf8_lossy(&std::fs::read(file)?);
        res += "\n";
    }

    Ok(res)
}

#[test]
fn asdf() {
    let x = locate_byproducts(
        "sample/target/release/deps/libsample-7aab9f7e7ab26e00.rlib",
        "ll",
    );

    todo!("{:?}", x);
}
