use crate::esafeprintln;
use ar::Archive;
use cargo_metadata::Artifact;
use std::{
    fs::File,
    path::{Path, PathBuf},
};

pub fn artifact_byproducts(
    artifact: &Artifact,
    ext: &str,
    verbosity: usize,
) -> anyhow::Result<Vec<PathBuf>> {
    for file in artifact.filenames.iter() {
        if file.extension() == Some("rlib") {
            return locate_byproducts(file, ext, verbosity);
        }
    }
    anyhow::bail!("no rmeta?");
}

/// Look inside of rlib file to figure out artifact names
///
/// rlib files are ar archives [1] and contain object code generated by compiler. multiple
/// compilation units we can abuse names of the object files to get names of emitted byproducts:
///
/// sample-7aab9f7e7ab26e00.53xe9n61hxojleor.rcgu.o =>
/// sample-7aab9f7e7ab26e00.53xe9n61hxojleor.rcgu.s
///
/// This is needed so we can tell which files were generated
///
/// - [1] https://rustc-dev-guide.rust-lang.org/backend/libs-and-metadata.html
pub fn locate_byproducts(
    rlib: impl AsRef<Path>,
    ext: &str,
    verbosity: usize,
) -> anyhow::Result<Vec<PathBuf>> {
    let mut res = Vec::new();
    let rlib = rlib.as_ref();
    let mut archive = Archive::new(File::open(rlib).unwrap());

    let basedir = rlib
        .parent()
        .ok_or_else(|| anyhow::anyhow!("Can't get a folder of {rlib:?}"))?
        .join("deps");

    if verbosity > 2 {
        esafeprintln!("Base dir with source files is {basedir:?}");
    }

    let mut missing = Vec::new();
    while let Some(entry) = archive.next_entry() {
        let entry = entry?;
        let name = std::str::from_utf8(entry.header().identifier())?;
        if name == "lib.rmeta" {
            continue;
        }

        let mut file = basedir.join(name);
        file.set_extension(ext);
        if file.exists() {
            if verbosity > 2 {
                esafeprintln!("Found a byproduct {file:?}");
            }
            res.push(file)
        } else {
            esafeprintln!("Expected byproduct {file:?} doesn't exist");
            missing.push(file);
        }
    }
    if !res.is_empty() && missing.is_empty() {
        for file in &missing {
            esafeprintln!("A byproduct is supposed to be located at {file:?}, but it's missing");
        }
    }

    if missing.len() == 1 && res.is_empty() {
        if verbosity > 1 {
            esafeprintln!("Converting {:?} to a single byproduct", missing[0]);
        }
        assert_eq!(missing[0].extension().unwrap(), ext);
        let mut singleton = missing.remove(0);
        if verbosity > 2 {
            esafeprintln!("Going to strip extensions from {singleton:?}");
        }
        while singleton.extension().is_some() {
            singleton = singleton.with_extension("");
        }

        let singleton = singleton.with_extension(ext);
        if singleton.exists() {
            return Ok(vec![singleton]);
        } else {
            for f in basedir.read_dir()? {
                let f = f.unwrap();
                crate::safeprintln!("- {:?}", f.file_name());
            }
            anyhow::bail!("Expected to find a single byproduct file at {singleton:?}, it doesn't exist there either");
        }
    }

    Ok(res)
}

pub fn read_files(paths: &[PathBuf]) -> anyhow::Result<String> {
    let mut res = String::new();

    for file in paths {
        res += &String::from_utf8_lossy(&std::fs::read(file)?);
        res += "\n";
    }

    Ok(res)
}
